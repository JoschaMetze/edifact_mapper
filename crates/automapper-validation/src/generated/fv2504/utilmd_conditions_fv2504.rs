// <auto-generated>
// Generated by automapper-generator generate-conditions
// AHB: xml-migs-and-ahbs/FV2504/UTILMD_AHB_Strom_2_1_Fehlerkorrektur_20250623.xml
// Generated: 2026-02-25T10:00:46Z
// </auto-generated>

use crate::eval::{ConditionEvaluator, ConditionResult, EvaluationContext};

/// Generated condition evaluator for UTILMD FV2504.
pub struct UtilmdConditionEvaluatorFV2504 {
    // External condition IDs that require runtime context.
    external_conditions: std::collections::HashSet<u32>,
}

impl Default for UtilmdConditionEvaluatorFV2504 {
    fn default() -> Self {
        let mut external_conditions = std::collections::HashSet::new();
        external_conditions.insert(1);
        external_conditions.insert(4);
        external_conditions.insert(5);
        external_conditions.insert(6);
        Self { external_conditions }
    }
}

impl ConditionEvaluator for UtilmdConditionEvaluatorFV2504 {
    fn message_type(&self) -> &str {
        "UTILMD"
    }

    fn format_version(&self) -> &str {
        "FV2504"
    }

    fn evaluate(&self, condition: u32, ctx: &EvaluationContext) -> ConditionResult {
        match condition {
            1 => self.evaluate_1(ctx),
            4 => self.evaluate_4(ctx),
            5 => self.evaluate_5(ctx),
            6 => self.evaluate_6(ctx),
            7 => self.evaluate_7(ctx),
            _ => ConditionResult::Unknown,
        }
    }

    fn is_external(&self, condition: u32) -> bool {
        self.external_conditions.contains(&condition)
    }
}

impl UtilmdConditionEvaluatorFV2504 {
    /// [1] Wenn Aufteilung vorhanden
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_1(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("message_splitting")
    }

    /// [4] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_4(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_lf")
    }

    /// [5] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_5(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_lf")
    }

    /// [6] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle ÜNB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_6(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_uenb")
    }

    /// [7] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) vorhanden
    fn evaluate_7(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        match sts_segments.first() {
            Some(sts) => {
                match sts.elements.get(2).and_then(|e| e.first()).map(|s| s.as_str()) {
                    Some("ZG9") | Some("ZH1") | Some("ZH2") => ConditionResult::True,
                    Some(_) => ConditionResult::False,
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

}
