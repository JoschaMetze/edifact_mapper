// <auto-generated>
// Generated by automapper-generator generate-conditions
// AHB: xml-migs-and-ahbs/FV2504/UTILMD_AHB_Strom_2_1_Fehlerkorrektur_20250623.xml
// Generated: 2026-02-25T13:06:44Z
// </auto-generated>

use crate::eval::{ConditionEvaluator, ConditionResult, EvaluationContext};

/// Generated condition evaluator for UTILMD FV2504.
pub struct UtilmdConditionEvaluatorFV2504 {
    // External condition IDs that require runtime context.
    external_conditions: std::collections::HashSet<u32>,
}

impl Default for UtilmdConditionEvaluatorFV2504 {
    fn default() -> Self {
        let mut external_conditions = std::collections::HashSet::new();
        external_conditions.insert(1);
        external_conditions.insert(4);
        external_conditions.insert(5);
        external_conditions.insert(6);
        external_conditions.insert(8);
        external_conditions.insert(9);
        external_conditions.insert(14);
        external_conditions.insert(30);
        external_conditions.insert(31);
        external_conditions.insert(34);
        Self {
            external_conditions,
        }
    }
}

impl ConditionEvaluator for UtilmdConditionEvaluatorFV2504 {
    fn message_type(&self) -> &str {
        "UTILMD"
    }

    fn format_version(&self) -> &str {
        "FV2504"
    }

    fn evaluate(&self, condition: u32, ctx: &EvaluationContext) -> ConditionResult {
        match condition {
            1 => self.evaluate_1(ctx),
            4 => self.evaluate_4(ctx),
            5 => self.evaluate_5(ctx),
            6 => self.evaluate_6(ctx),
            7 => self.evaluate_7(ctx),
            8 => self.evaluate_8(ctx),
            9 => self.evaluate_9(ctx),
            10 => self.evaluate_10(ctx),
            11 => self.evaluate_11(ctx),
            12 => self.evaluate_12(ctx),
            13 => self.evaluate_13(ctx),
            14 => self.evaluate_14(ctx),
            15 => self.evaluate_15(ctx),
            16 => self.evaluate_16(ctx),
            17 => self.evaluate_17(ctx),
            18 => self.evaluate_18(ctx),
            19 => self.evaluate_19(ctx),
            20 => self.evaluate_20(ctx),
            21 => self.evaluate_21(ctx),
            22 => self.evaluate_22(ctx),
            23 => self.evaluate_23(ctx),
            24 => self.evaluate_24(ctx),
            25 => self.evaluate_25(ctx),
            27 => self.evaluate_27(ctx),
            30 => self.evaluate_30(ctx),
            31 => self.evaluate_31(ctx),
            32 => self.evaluate_32(ctx),
            33 => self.evaluate_33(ctx),
            34 => self.evaluate_34(ctx),
            35 => self.evaluate_35(ctx),
            36 => self.evaluate_36(ctx),
            _ => ConditionResult::Unknown,
        }
    }

    fn is_external(&self, condition: u32) -> bool {
        self.external_conditions.contains(&condition)
    }
}

impl UtilmdConditionEvaluatorFV2504 {
    /// [27] Wenn das DE2380 von SG4 DTM+Z01 (Kündigungsfrist des Vertrags) an vierter Stelle ein T oder R enthält
    fn evaluate_27(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "Z01");
        match dtm_segments.first() {
            Some(dtm) => {
                match dtm
                    .elements
                    .first()
                    .and_then(|e| e.get(1))
                    .map(|s| s.as_str())
                {
                    Some(value) => match value.chars().nth(3) {
                        Some('T') | Some('R') => ConditionResult::True,
                        Some(_) => ConditionResult::False,
                        None => ConditionResult::Unknown,
                    },
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [30] Wenn Antwort auf Aktivierung übermittelt wird
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_30(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("is_answer_to_activation")
    }

    /// [31] Wenn eine Korrektur erfolgt
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_31(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("is_correction")
    }

    /// [32] Wenn mehr als ein SG8 (Referenz auf die Lokationsbündelstruktur) vorhanden
    // REVIEW: SG8 groups for 'Referenz auf die Lokationsbündelstruktur' are identified by SEQ with codes Z78/ZC7/ZC8/ZD5. Each such SG8 begins with exactly one such SEQ, so counting all SEQ segments with those codes gives the number of Lokationsbündelstruktur SG8 instances in the message. More than 1 → True. (medium confidence)
    fn evaluate_32(&self, ctx: &EvaluationContext) -> ConditionResult {
        let lokationsbuendel_codes = ["Z78", "ZC7", "ZC8", "ZD5"];
        let count: usize = lokationsbuendel_codes
            .iter()
            .map(|code| ctx.find_segments_with_qualifier("SEQ", 0, code).len())
            .sum();
        if count > 1 {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [33] Wenn in einer SG8 SEQ+Z79 im PIA+5 (Erforderliches Produkt) DE7140 ein Produkt-Code genannt ist, der in der Codeliste der Konfigurationen im Kapitel 6 "Produkte zur Bestellung / Änderung von Daten" in der Spalte "Code der Produkteigenschaft 9991000002272 („Lieferant“ (Empfänger der Vergütung zur Einspeisung)) befüllt ist.
    fn evaluate_33(&self, _ctx: &EvaluationContext) -> ConditionResult {
        // TODO: Condition [33] requires manual implementation
        // Reason: This requires checking whether PIA+5 DE7140 in an SG8 containing SEQ+Z79 holds a code from a specific column ('Code der Produkteigenschaft 9991000002272, Lieferant als Empfänger der Vergütung') of an external code list from chapter 6. The set of valid codes for that column is not derivable from the EDIFACT data itself and must come from the external specification document.
        ConditionResult::Unknown
    }

    /// [34] Wenn Antwort auf Deaktivierung übermittelt wird
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_34(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("is_answer_to_deactivation")
    }

    /// [35] Wenn das DE2380 von SG4 DTM+Z01 (Kündigungsfrist des Vertrags) an vierter Stelle T (Termin) enthält
    fn evaluate_35(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "Z01");
        match dtm_segments.first() {
            Some(dtm) => {
                match dtm
                    .elements
                    .first()
                    .and_then(|e| e.get(1))
                    .map(|s| s.as_str())
                {
                    Some(value) => match value.chars().nth(3) {
                        Some('T') => ConditionResult::True,
                        Some(_) => ConditionResult::False,
                        None => ConditionResult::Unknown,
                    },
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [36] Wenn in derselben SG8 SEQ+Z79 im PIA+5 (Erforderliches Produkt) DE7140 ein Produkt-Code genannt ist, der in der Codeliste der Konfigurationen im Kapitel 6.1 "Anmeldung einer Zuordnung des LFN (UTILMD)" in der Spalte "Code der Produkteigenschaft (Wertebereich)" mit einem Code befüllt ist.
    fn evaluate_36(&self, _ctx: &EvaluationContext) -> ConditionResult {
        // TODO: Condition [36] requires manual implementation
        // Reason: GROUP-SCOPED condition requiring knowledge of specific code list values from chapter 6.1 ('Anmeldung einer Zuordnung des LFN', column 'Code der Produkteigenschaft (Wertebereich)'). While the group-scoped check for SEQ+Z79 and PIA+5 in the same SG8 is implementable, correctly filtering DE7140 to codes present in that specific code list column requires the external specification document values, which are not available from EDIFACT data alone.
        ConditionResult::Unknown
    }

    /// [1] Wenn Aufteilung vorhanden
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_1(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("message_splitting")
    }

    /// [4] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_4(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_lf")
    }

    /// [5] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_5(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_lf")
    }

    /// [6] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle ÜNB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_6(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_uenb")
    }

    /// [7] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) vorhanden
    fn evaluate_7(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        match sts_segments.first() {
            Some(sts) => {
                match sts
                    .elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                {
                    Some("ZG9") | Some("ZH1") | Some("ZH2") => ConditionResult::True,
                    Some(_) => ConditionResult::False,
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [8] Wenn für Datenclearing erforderlich
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_8(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("data_clearing_required")
    }

    /// [9] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle MSB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_9(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_msb")
    }

    /// [10] Wenn SG4 STS+7++xxx+xxx+E01/E03 (Transaktionsgrund befristete Anmeldung) vorhanden
    fn evaluate_10(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some("E01" | "E03") = sts
                .elements
                .get(4)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
            {
                return ConditionResult::True;
            }
        }
        if sts_segments.is_empty() {
            ConditionResult::Unknown
        } else {
            ConditionResult::False
        }
    }

    /// [11] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) nicht vorhanden
    fn evaluate_11(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some("ZG9" | "ZH1" | "ZH2") = sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
            {
                return ConditionResult::False;
            }
        }
        ConditionResult::True
    }

    /// [12] Wenn SG4 DTM+471 (Ende zum nächstmöglichem Termin) nicht vorhanden
    fn evaluate_12(&self, ctx: &EvaluationContext) -> ConditionResult {
        if ctx.find_segments_with_qualifier("DTM", 0, "471").is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [13] Wenn SG4 STS+E01++Z01 (Status der Antwort: Zustimmung mit Terminänderung) nicht vorhanden
    fn evaluate_13(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .is_some_and(|v| v == "Z01")
            {
                return ConditionResult::False;
            }
        }
        ConditionResult::True
    }

    /// [14] Wenn Datum bekannt
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: 'Wenn Datum bekannt' (When date is known) reflects whether the sender has knowledge of a specific date at the time of sending. This cannot be determined from the EDIFACT message structure itself — a missing DTM segment is ambiguous between 'date unknown' and 'date not applicable'. Requires external business context. (medium confidence)
    fn evaluate_14(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("date_known")
    }

    /// [15] Wenn in derselben SG8 das SEQ+Z98 (Informative Daten der Marktlokation) vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_15(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                if !ctx
                    .find_segments_with_qualifier_in_group("SEQ", 0, "Z98", group_path, i)
                    .is_empty()
                {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        if ctx.find_segments_with_qualifier("SEQ", 0, "Z98").is_empty() {
            ConditionResult::False
        } else {
            ConditionResult::True
        }
    }

    /// [16] Wenn SG4 STS+E01++Z12 (Status der Antwort: Ablehnung Vertragsbindung) vorhanden
    fn evaluate_16(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .is_some_and(|v| v == "Z12")
            {
                return ConditionResult::True;
            }
        }
        ConditionResult::False
    }

    /// [17] Wenn in derselben SG8 das SEQ+Z01/Z80/Z81 (Daten der Marktlokation) vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_17(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let segs = ctx.find_segments_in_group("SEQ", group_path, i);
                if segs.iter().any(|seg| {
                    seg.elements
                        .first()
                        .and_then(|e| e.first())
                        .map(|s| s.as_str())
                        .is_some_and(|v| v == "Z01" || v == "Z80" || v == "Z81")
                }) {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx.find_segments("SEQ").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z01" || v == "Z80" || v == "Z81")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [18] Wenn SG4 DTM+93 (Ende zum) nicht vorhanden
    fn evaluate_18(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "93");
        if dtm_segments.is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [19] Wenn SG8 SEQ+Z01/Z98 (Daten der Marktlokation) SG10 CCI+++ZC0 (Prognose auf Basis von Werten) vorhanden
    /// Group-scoped: checks SEQ+CCI co-occurrence within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_19(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let seq_present =
                    ctx.find_segments_in_group("SEQ", group_path, i)
                        .iter()
                        .any(|seg| {
                            seg.elements
                                .first()
                                .and_then(|e| e.first())
                                .map(|s| s.as_str())
                                .is_some_and(|v| v == "Z01" || v == "Z98")
                        });
                let cci_present =
                    ctx.find_segments_in_group("CCI", group_path, i)
                        .iter()
                        .any(|seg| {
                            seg.elements
                                .get(2)
                                .and_then(|e| e.first())
                                .map(|s| s.as_str())
                                .is_some_and(|v| v == "ZC0")
                        });
                if seq_present && cci_present {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let seq_present = ctx.find_segments("SEQ").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z01" || v == "Z98")
        });
        if !seq_present {
            return ConditionResult::False;
        }
        let cci_present = ctx.find_segments("CCI").iter().any(|seg| {
            seg.elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "ZC0")
        });
        if cci_present {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [20] Wenn SG8 SEQ+Z01 (Daten der Marktlokation) SG10 CCI+Z30++Z07 (Verbrauch) vorhanden
    /// Group-scoped: checks SEQ+CCI co-occurrence within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_20(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let seq_present = !ctx
                    .find_segments_with_qualifier_in_group("SEQ", 0, "Z01", group_path, i)
                    .is_empty();
                let cci_present = ctx
                    .find_segments_with_qualifier_in_group("CCI", 0, "Z30", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "Z07")
                    });
                if seq_present && cci_present {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let seq_present = !ctx.find_segments_with_qualifier("SEQ", 0, "Z01").is_empty();
        if !seq_present {
            return ConditionResult::False;
        }
        let cci_present = ctx
            .find_segments_with_qualifier("CCI", 0, "Z30")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "Z07")
            });
        if cci_present {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [21] Wenn SG10 CCI+++ZA6 (Prognose auf Basis von Profilen) in dieser SG8 vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_21(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_in_group("CCI", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "ZA6")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx.find_segments("CCI").iter().any(|seg| {
            seg.elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "ZA6")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [22] Es ist die Zeitraum-ID vom DE1156 aus einem passenden SG6 RFF+Z47/ Z48/ Z49 (Verwendungszeitraum der Daten) einzutragen
    // REVIEW: The condition instructs that the Zeitraum-ID (DE1156) from a matching SG6 RFF+Z47/Z48/Z49 (Verwendungszeitraum der Daten) must be entered. Interpreted as: this condition is True when such an RFF segment (with qualifier Z47, Z48, or Z49 at elements[0][0]) is present in the message. The schema for RFF — Verwendungszeitraum der Daten lists those qualifiers at elements[0][0]. Confidence medium because the wording is instructional rather than a pure boolean predicate. (medium confidence)
    fn evaluate_22(&self, ctx: &EvaluationContext) -> ConditionResult {
        let found = ctx.find_segments("RFF").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z47" || v == "Z48" || v == "Z49")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [23] Wenn in dieser SG4 das STS+E01++A05/A99 (Status der Antwort) vorhanden
    /// Group-scoped: checks within SG4 instances, falls back to message-wide.
    fn evaluate_23(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_with_qualifier_in_group("STS", 0, "E01", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "A05" || v == "A99")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx
            .find_segments_with_qualifier("STS", 0, "E01")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "A05" || v == "A99")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [24] Wenn in dieser SG4 das STS+E01++A25/A99 (Status der Antwort) vorhanden
    /// Group-scoped: checks within SG4 instances, falls back to message-wide.
    fn evaluate_24(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_with_qualifier_in_group("STS", 0, "E01", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "A25" || v == "A99")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx
            .find_segments_with_qualifier("STS", 0, "E01")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "A25" || v == "A99")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [25] Wenn die Veräußerungsform der erzeugenden Marktlokation der Marktprämie zugeordnet ist
    fn evaluate_25(&self, ctx: &EvaluationContext) -> ConditionResult {
        let found = ctx
            .find_segments_with_qualifier("CCI", 0, "Z22")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "Z91")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }
}
