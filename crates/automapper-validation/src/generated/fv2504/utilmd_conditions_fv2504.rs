// <auto-generated>
// Generated by automapper-generator generate-conditions
// AHB: xml-migs-and-ahbs/FV2504/UTILMD_AHB_Strom_2_1_Fehlerkorrektur_20250623.xml
// Generated: 2026-02-25T13:36:32Z
// </auto-generated>

use crate::eval::{ConditionEvaluator, ConditionResult, EvaluationContext};

/// Generated condition evaluator for UTILMD FV2504.
pub struct UtilmdConditionEvaluatorFV2504 {
    // External condition IDs that require runtime context.
    external_conditions: std::collections::HashSet<u32>,
}

impl Default for UtilmdConditionEvaluatorFV2504 {
    fn default() -> Self {
        let mut external_conditions = std::collections::HashSet::new();
        external_conditions.insert(1);
        external_conditions.insert(4);
        external_conditions.insert(5);
        external_conditions.insert(6);
        external_conditions.insert(8);
        external_conditions.insert(9);
        external_conditions.insert(14);
        external_conditions.insert(30);
        external_conditions.insert(31);
        external_conditions.insert(33);
        external_conditions.insert(34);
        external_conditions.insert(36);
        external_conditions.insert(37);
        external_conditions.insert(38);
        external_conditions.insert(39);
        Self {
            external_conditions,
        }
    }
}

impl ConditionEvaluator for UtilmdConditionEvaluatorFV2504 {
    fn message_type(&self) -> &str {
        "UTILMD"
    }

    fn format_version(&self) -> &str {
        "FV2504"
    }

    fn evaluate(&self, condition: u32, ctx: &EvaluationContext) -> ConditionResult {
        match condition {
            1 => self.evaluate_1(ctx),
            4 => self.evaluate_4(ctx),
            5 => self.evaluate_5(ctx),
            6 => self.evaluate_6(ctx),
            7 => self.evaluate_7(ctx),
            8 => self.evaluate_8(ctx),
            9 => self.evaluate_9(ctx),
            10 => self.evaluate_10(ctx),
            11 => self.evaluate_11(ctx),
            12 => self.evaluate_12(ctx),
            13 => self.evaluate_13(ctx),
            14 => self.evaluate_14(ctx),
            15 => self.evaluate_15(ctx),
            16 => self.evaluate_16(ctx),
            17 => self.evaluate_17(ctx),
            18 => self.evaluate_18(ctx),
            19 => self.evaluate_19(ctx),
            20 => self.evaluate_20(ctx),
            21 => self.evaluate_21(ctx),
            22 => self.evaluate_22(ctx),
            23 => self.evaluate_23(ctx),
            24 => self.evaluate_24(ctx),
            25 => self.evaluate_25(ctx),
            27 => self.evaluate_27(ctx),
            30 => self.evaluate_30(ctx),
            31 => self.evaluate_31(ctx),
            32 => self.evaluate_32(ctx),
            33 => self.evaluate_33(ctx),
            34 => self.evaluate_34(ctx),
            35 => self.evaluate_35(ctx),
            36 => self.evaluate_36(ctx),
            37 => self.evaluate_37(ctx),
            38 => self.evaluate_38(ctx),
            39 => self.evaluate_39(ctx),
            _ => ConditionResult::Unknown,
        }
    }

    fn is_external(&self, condition: u32) -> bool {
        self.external_conditions.contains(&condition)
    }
}

impl UtilmdConditionEvaluatorFV2504 {
    /// [30] Wenn Antwort auf Aktivierung übermittelt wird
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: Whether a message is a response to an activation (Antwort auf Aktivierung) depends on the Transaktionsgrund code in the STS segment. The exact STS Transaktionsgrund codes identifying activation responses for controllable resources (steuerbare Ressource) in UTILMD FV2504 are not provided in the segment structure reference and require business-context resolution via the external provider. (medium confidence)
    fn evaluate_30(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("response_to_activation")
    }

    /// [31] Wenn eine Korrektur erfolgt
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: Whether a correction (Korrektur) is occurring is encoded in the STS Transaktionsgrund field. The exact Transaktionsgrund codes denoting a correction in this UTILMD variant are not listed in the segment structure reference, making this an external business-context condition rather than a structurally derivable one. (medium confidence)
    fn evaluate_31(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("correction_in_progress")
    }

    /// [33] Wenn in einer SG8 SEQ+Z79 im PIA+5 (Erforderliches Produkt) DE7140 ein Produkt-Code genannt ist, der in der Codeliste der Konfigurationen im Kapitel 6 "Produkte zur Bestellung / Änderung von Daten" in der Spalte "Code der Produkteigenschaft 9991000002272 („Lieferant“ (Empfänger der Vergütung zur Einspeisung)) befüllt ist.
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: Checks whether the product code in PIA DE7140 (within any SG8 containing SEQ+Z79) belongs to the code list subset for product property 9991000002272 ('Lieferant' / recipient of feed-in compensation) defined in chapter 6. Code list membership cannot be evaluated from the EDIFACT message alone — it requires the external configuration code list to look up which product codes are assigned to that property column. (medium confidence)
    fn evaluate_33(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external
            .evaluate("seq_z79_has_lieferant_feed_in_product_code")
    }

    /// [34] Wenn Antwort auf Deaktivierung übermittelt wird
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: Symmetric counterpart to condition 30 for deactivation (Deaktivierung). Whether a message is a deactivation response depends on the STS Transaktionsgrund code. The specific code values for deactivation responses in UTILMD FV2504 are not confirmed in the segment structure reference and must be resolved via external business context. (medium confidence)
    fn evaluate_34(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("response_to_deactivation")
    }

    /// [36] Wenn in derselben SG8 SEQ+Z79 im PIA+5 (Erforderliches Produkt) DE7140 ein Produkt-Code genannt ist, der in der Codeliste der Konfigurationen im Kapitel 6.1 "Anmeldung einer Zuordnung des LFN (UTILMD)" in der Spalte "Code der Produkteigenschaft (Wertebereich)" mit einem Code befüllt ist.
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: GROUP-SCOPED. Checks whether in the same SG8, the product code in PIA+5 DE7140 (paired with SEQ+Z79) belongs to the code list for section 6.1 'Anmeldung einer Zuordnung des LFN (UTILMD)' — specifically the 'Code der Produkteigenschaft (Wertebereich)' column. Code list membership requires external reference data not present in the EDIFACT message itself. (medium confidence)
    fn evaluate_36(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external
            .evaluate("seq_z79_has_lfa_registration_product_code")
    }

    /// [37] Wenn Anmeldung/ Änderung befristet
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: Whether a registration/change (Anmeldung/Änderung) is time-limited (befristet) is semantically about whether an end-date has been specified. While it may correlate with the presence of a specific DTM qualifier (e.g., DTM+36 for period end), the exact DTM qualifier used to signal 'befristet' in this UTILMD PID context is not confirmed in the segment structure reference. Marking as external to avoid misidentifying the wrong qualifier. (medium confidence)
    fn evaluate_37(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("registration_is_time_limited")
    }

    /// [38] Es sind nur die Code der Produkteigenschaft zu dem in derselben SG8 SEQ+Z79 im PIA+5 (Erforderliches Produkt) DE7140 erlaubt, die in der Codeliste der Konfigurationen im Kapitel  6.1 "Anmeldung einer Zuordnung des LFN (UTILMD)" in derselben Zeile wie der Produkt-Code stehen und in der Spalte "Code der Produkteigenschaft (Wertebereich)" genannt sind.
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: GROUP-SCOPED. This condition enforces that only property codes permitted for the specific product code found in PIA+5 DE7140 (SEQ+Z79, same SG8) are used. Resolving which property codes are allowed for a given product code requires a cross-reference lookup in the external code list for section 6.1 — this cannot be evaluated from the EDIFACT message structure alone. (medium confidence)
    fn evaluate_38(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external
            .evaluate("seq_z79_product_property_values_in_allowed_set")
    }

    /// [39] Wenn in derselben SG8 SEQ+Z79 m PIA+5 (Erforderliches Produkt) DE7140 ein Produkt-Code genannt ist, der in der Codeliste der Konfigurationen im Kapitel 6.1 "Anmeldung einer Zuordnung des LFN (UTILMD)" in der Spalte "Wertedetails für Position" die ggf. enthaltene Bedingung erfüllt ist
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: GROUP-SCOPED. Checks whether the optional condition specified in the 'Wertedetails für Position' column of the external code list is fulfilled for the product code in PIA+5 DE7140 (SEQ+Z79, same SG8). These per-product-code positional conditions are defined entirely in the external code list and cannot be derived from the EDIFACT message structure. (medium confidence)
    fn evaluate_39(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external
            .evaluate("seq_z79_product_code_position_condition_fulfilled")
    }

    /// [1] Wenn Aufteilung vorhanden
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_1(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("message_splitting")
    }

    /// [4] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_4(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_lf")
    }

    /// [5] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_5(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_lf")
    }

    /// [6] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle ÜNB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_6(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_uenb")
    }

    /// [7] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) vorhanden
    fn evaluate_7(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        match sts_segments.first() {
            Some(sts) => {
                match sts
                    .elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                {
                    Some("ZG9") | Some("ZH1") | Some("ZH2") => ConditionResult::True,
                    Some(_) => ConditionResult::False,
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [8] Wenn für Datenclearing erforderlich
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_8(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("data_clearing_required")
    }

    /// [9] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle MSB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_9(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_msb")
    }

    /// [10] Wenn SG4 STS+7++xxx+xxx+E01/E03 (Transaktionsgrund befristete Anmeldung) vorhanden
    fn evaluate_10(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some("E01" | "E03") = sts
                .elements
                .get(4)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
            {
                return ConditionResult::True;
            }
        }
        if sts_segments.is_empty() {
            ConditionResult::Unknown
        } else {
            ConditionResult::False
        }
    }

    /// [11] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) nicht vorhanden
    fn evaluate_11(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some("ZG9" | "ZH1" | "ZH2") = sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
            {
                return ConditionResult::False;
            }
        }
        ConditionResult::True
    }

    /// [12] Wenn SG4 DTM+471 (Ende zum nächstmöglichem Termin) nicht vorhanden
    fn evaluate_12(&self, ctx: &EvaluationContext) -> ConditionResult {
        if ctx.find_segments_with_qualifier("DTM", 0, "471").is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [13] Wenn SG4 STS+E01++Z01 (Status der Antwort: Zustimmung mit Terminänderung) nicht vorhanden
    fn evaluate_13(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .is_some_and(|v| v == "Z01")
            {
                return ConditionResult::False;
            }
        }
        ConditionResult::True
    }

    /// [14] Wenn Datum bekannt
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: 'Wenn Datum bekannt' (When date is known) reflects whether the sender has knowledge of a specific date at the time of sending. This cannot be determined from the EDIFACT message structure itself — a missing DTM segment is ambiguous between 'date unknown' and 'date not applicable'. Requires external business context. (medium confidence)
    fn evaluate_14(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("date_known")
    }

    /// [15] Wenn in derselben SG8 das SEQ+Z98 (Informative Daten der Marktlokation) vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_15(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                if !ctx
                    .find_segments_with_qualifier_in_group("SEQ", 0, "Z98", group_path, i)
                    .is_empty()
                {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        if ctx.find_segments_with_qualifier("SEQ", 0, "Z98").is_empty() {
            ConditionResult::False
        } else {
            ConditionResult::True
        }
    }

    /// [16] Wenn SG4 STS+E01++Z12 (Status der Antwort: Ablehnung Vertragsbindung) vorhanden
    fn evaluate_16(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts
                .elements
                .get(2)
                .and_then(|e| e.first())
                .is_some_and(|v| v == "Z12")
            {
                return ConditionResult::True;
            }
        }
        ConditionResult::False
    }

    /// [17] Wenn in derselben SG8 das SEQ+Z01/Z80/Z81 (Daten der Marktlokation) vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_17(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let segs = ctx.find_segments_in_group("SEQ", group_path, i);
                if segs.iter().any(|seg| {
                    seg.elements
                        .first()
                        .and_then(|e| e.first())
                        .map(|s| s.as_str())
                        .is_some_and(|v| v == "Z01" || v == "Z80" || v == "Z81")
                }) {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx.find_segments("SEQ").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z01" || v == "Z80" || v == "Z81")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [18] Wenn SG4 DTM+93 (Ende zum) nicht vorhanden
    fn evaluate_18(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "93");
        if dtm_segments.is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [19] Wenn SG8 SEQ+Z01/Z98 (Daten der Marktlokation) SG10 CCI+++ZC0 (Prognose auf Basis von Werten) vorhanden
    /// Group-scoped: checks SEQ+CCI co-occurrence within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_19(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let seq_present =
                    ctx.find_segments_in_group("SEQ", group_path, i)
                        .iter()
                        .any(|seg| {
                            seg.elements
                                .first()
                                .and_then(|e| e.first())
                                .map(|s| s.as_str())
                                .is_some_and(|v| v == "Z01" || v == "Z98")
                        });
                let cci_present =
                    ctx.find_segments_in_group("CCI", group_path, i)
                        .iter()
                        .any(|seg| {
                            seg.elements
                                .get(2)
                                .and_then(|e| e.first())
                                .map(|s| s.as_str())
                                .is_some_and(|v| v == "ZC0")
                        });
                if seq_present && cci_present {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let seq_present = ctx.find_segments("SEQ").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z01" || v == "Z98")
        });
        if !seq_present {
            return ConditionResult::False;
        }
        let cci_present = ctx.find_segments("CCI").iter().any(|seg| {
            seg.elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "ZC0")
        });
        if cci_present {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [20] Wenn SG8 SEQ+Z01 (Daten der Marktlokation) SG10 CCI+Z30++Z07 (Verbrauch) vorhanden
    /// Group-scoped: checks SEQ+CCI co-occurrence within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_20(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let seq_present = !ctx
                    .find_segments_with_qualifier_in_group("SEQ", 0, "Z01", group_path, i)
                    .is_empty();
                let cci_present = ctx
                    .find_segments_with_qualifier_in_group("CCI", 0, "Z30", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "Z07")
                    });
                if seq_present && cci_present {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let seq_present = !ctx.find_segments_with_qualifier("SEQ", 0, "Z01").is_empty();
        if !seq_present {
            return ConditionResult::False;
        }
        let cci_present = ctx
            .find_segments_with_qualifier("CCI", 0, "Z30")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "Z07")
            });
        if cci_present {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [21] Wenn SG10 CCI+++ZA6 (Prognose auf Basis von Profilen) in dieser SG8 vorhanden
    /// Group-scoped: checks within SG4→SG8 instances, falls back to message-wide.
    fn evaluate_21(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4", "SG8"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_in_group("CCI", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "ZA6")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx.find_segments("CCI").iter().any(|seg| {
            seg.elements
                .get(2)
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "ZA6")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [22] Es ist die Zeitraum-ID vom DE1156 aus einem passenden SG6 RFF+Z47/ Z48/ Z49 (Verwendungszeitraum der Daten) einzutragen
    // REVIEW: The condition instructs that the Zeitraum-ID (DE1156) from a matching SG6 RFF+Z47/Z48/Z49 (Verwendungszeitraum der Daten) must be entered. Interpreted as: this condition is True when such an RFF segment (with qualifier Z47, Z48, or Z49 at elements[0][0]) is present in the message. The schema for RFF — Verwendungszeitraum der Daten lists those qualifiers at elements[0][0]. Confidence medium because the wording is instructional rather than a pure boolean predicate. (medium confidence)
    fn evaluate_22(&self, ctx: &EvaluationContext) -> ConditionResult {
        let found = ctx.find_segments("RFF").iter().any(|seg| {
            seg.elements
                .first()
                .and_then(|e| e.first())
                .map(|s| s.as_str())
                .is_some_and(|v| v == "Z47" || v == "Z48" || v == "Z49")
        });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [23] Wenn in dieser SG4 das STS+E01++A05/A99 (Status der Antwort) vorhanden
    /// Group-scoped: checks within SG4 instances, falls back to message-wide.
    fn evaluate_23(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_with_qualifier_in_group("STS", 0, "E01", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "A05" || v == "A99")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx
            .find_segments_with_qualifier("STS", 0, "E01")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "A05" || v == "A99")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [24] Wenn in dieser SG4 das STS+E01++A25/A99 (Status der Antwort) vorhanden
    /// Group-scoped: checks within SG4 instances, falls back to message-wide.
    fn evaluate_24(&self, ctx: &EvaluationContext) -> ConditionResult {
        let group_path: &[&str] = &["SG4"];
        let instance_count = ctx.group_instance_count(group_path);
        if instance_count > 0 {
            for i in 0..instance_count {
                let found = ctx
                    .find_segments_with_qualifier_in_group("STS", 0, "E01", group_path, i)
                    .iter()
                    .any(|seg| {
                        seg.elements
                            .get(2)
                            .and_then(|e| e.first())
                            .map(|s| s.as_str())
                            .is_some_and(|v| v == "A25" || v == "A99")
                    });
                if found {
                    return ConditionResult::True;
                }
            }
            return ConditionResult::False;
        }
        // Fallback: message-wide search
        let found = ctx
            .find_segments_with_qualifier("STS", 0, "E01")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "A25" || v == "A99")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [25] Wenn die Veräußerungsform der erzeugenden Marktlokation der Marktprämie zugeordnet ist
    fn evaluate_25(&self, ctx: &EvaluationContext) -> ConditionResult {
        let found = ctx
            .find_segments_with_qualifier("CCI", 0, "Z22")
            .iter()
            .any(|seg| {
                seg.elements
                    .get(2)
                    .and_then(|e| e.first())
                    .map(|s| s.as_str())
                    .is_some_and(|v| v == "Z91")
            });
        if found {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [27] Wenn das DE2380 von SG4 DTM+Z01 (Kündigungsfrist des Vertrags) an vierter Stelle ein T oder R enthält
    fn evaluate_27(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "Z01");
        match dtm_segments.first() {
            Some(dtm) => {
                match dtm
                    .elements
                    .first()
                    .and_then(|e| e.get(1))
                    .map(|s| s.as_str())
                {
                    Some(value) => match value.chars().nth(3) {
                        Some('T') | Some('R') => ConditionResult::True,
                        Some(_) => ConditionResult::False,
                        None => ConditionResult::Unknown,
                    },
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [32] Wenn mehr als ein SG8 (Referenz auf die Lokationsbündelstruktur) vorhanden
    // REVIEW: SG8 groups for 'Referenz auf die Lokationsbündelstruktur' are identified by SEQ with codes Z78/ZC7/ZC8/ZD5. Each such SG8 begins with exactly one such SEQ, so counting all SEQ segments with those codes gives the number of Lokationsbündelstruktur SG8 instances in the message. More than 1 → True. (medium confidence)
    fn evaluate_32(&self, ctx: &EvaluationContext) -> ConditionResult {
        let lokationsbuendel_codes = ["Z78", "ZC7", "ZC8", "ZD5"];
        let count: usize = lokationsbuendel_codes
            .iter()
            .map(|code| ctx.find_segments_with_qualifier("SEQ", 0, code).len())
            .sum();
        if count > 1 {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [35] Wenn das DE2380 von SG4 DTM+Z01 (Kündigungsfrist des Vertrags) an vierter Stelle T (Termin) enthält
    fn evaluate_35(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "Z01");
        match dtm_segments.first() {
            Some(dtm) => {
                match dtm
                    .elements
                    .first()
                    .and_then(|e| e.get(1))
                    .map(|s| s.as_str())
                {
                    Some(value) => match value.chars().nth(3) {
                        Some('T') => ConditionResult::True,
                        Some(_) => ConditionResult::False,
                        None => ConditionResult::Unknown,
                    },
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }
}
