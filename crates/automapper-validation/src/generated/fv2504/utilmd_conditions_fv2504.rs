// <auto-generated>
// Generated by automapper-generator generate-conditions
// AHB: xml-migs-and-ahbs/FV2504/UTILMD_AHB_Strom_2_1_Fehlerkorrektur_20250623.xml
// Generated: 2026-02-25T10:42:56Z
// </auto-generated>

use crate::eval::{ConditionEvaluator, ConditionResult, EvaluationContext};

/// Generated condition evaluator for UTILMD FV2504.
pub struct UtilmdConditionEvaluatorFV2504 {
    // External condition IDs that require runtime context.
    external_conditions: std::collections::HashSet<u32>,
}

impl Default for UtilmdConditionEvaluatorFV2504 {
    fn default() -> Self {
        let mut external_conditions = std::collections::HashSet::new();
        external_conditions.insert(1);
        external_conditions.insert(4);
        external_conditions.insert(5);
        external_conditions.insert(6);
        external_conditions.insert(8);
        external_conditions.insert(9);
        external_conditions.insert(14);
        Self { external_conditions }
    }
}

impl ConditionEvaluator for UtilmdConditionEvaluatorFV2504 {
    fn message_type(&self) -> &str {
        "UTILMD"
    }

    fn format_version(&self) -> &str {
        "FV2504"
    }

    fn evaluate(&self, condition: u32, ctx: &EvaluationContext) -> ConditionResult {
        match condition {
            1 => self.evaluate_1(ctx),
            4 => self.evaluate_4(ctx),
            5 => self.evaluate_5(ctx),
            6 => self.evaluate_6(ctx),
            7 => self.evaluate_7(ctx),
            8 => self.evaluate_8(ctx),
            9 => self.evaluate_9(ctx),
            10 => self.evaluate_10(ctx),
            11 => self.evaluate_11(ctx),
            12 => self.evaluate_12(ctx),
            13 => self.evaluate_13(ctx),
            14 => self.evaluate_14(ctx),
            15 => self.evaluate_15(ctx),
            16 => self.evaluate_16(ctx),
            18 => self.evaluate_18(ctx),
            _ => ConditionResult::Unknown,
        }
    }

    fn is_external(&self, condition: u32) -> bool {
        self.external_conditions.contains(&condition)
    }
}

impl UtilmdConditionEvaluatorFV2504 {
    /// [14] Wenn Datum bekannt
    /// EXTERNAL: Requires context from outside the message.
    // REVIEW: 'Wenn Datum bekannt' (When date is known) reflects whether the sender has knowledge of a specific date at the time of sending. This cannot be determined from the EDIFACT message structure itself — a missing DTM segment is ambiguous between 'date unknown' and 'date not applicable'. Requires external business context. (medium confidence)
    fn evaluate_14(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("date_known")
    }

    /// [15] Wenn in derselben SG8 das SEQ+Z98 (Informative Daten der Marktlokation) vorhanden
    // REVIEW: Checks for presence of SEQ+Z98 (Daten der Marktlokation) using elements[0][0]=="Z98" per the Segment Structure Reference (SEQ Daten der Marktlokation codes include Z98). The 'in derselben SG8' (same SG8 group) constraint cannot be precisely enforced with the flat segments API — the check covers the full message. In practice this is sufficient since Z98 identifies a specific Marktlokation data group and its co-occurrence within the same SG8 is the typical structural pattern. (medium confidence)
    fn evaluate_15(&self, ctx: &EvaluationContext) -> ConditionResult {
        let seq_z98 = ctx.find_segments_with_qualifier("SEQ", 0, "Z98");
        if seq_z98.is_empty() {
            ConditionResult::False
        } else {
            ConditionResult::True
        }
    }

    /// [1] Wenn Aufteilung vorhanden
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_1(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("message_splitting")
    }

    /// [4] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_4(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_lf")
    }

    /// [5] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle LF
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_5(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_lf")
    }

    /// [6] Wenn MP-ID in SG2 NAD+MR (Nachrichtenempfänger) in der Rolle ÜNB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_6(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("recipient_is_uenb")
    }

    /// [7] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) vorhanden
    fn evaluate_7(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        match sts_segments.first() {
            Some(sts) => {
                match sts.elements.get(2).and_then(|e| e.first()).map(|s| s.as_str()) {
                    Some("ZG9") | Some("ZH1") | Some("ZH2") => ConditionResult::True,
                    Some(_) => ConditionResult::False,
                    None => ConditionResult::Unknown,
                }
            }
            None => ConditionResult::Unknown,
        }
    }

    /// [8] Wenn für Datenclearing erforderlich
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_8(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("data_clearing_required")
    }

    /// [9] Wenn MP-ID in SG2 NAD+MS (Nachrichtenabsender) in der Rolle MSB
    /// EXTERNAL: Requires context from outside the message.
    fn evaluate_9(&self, ctx: &EvaluationContext) -> ConditionResult {
        ctx.external.evaluate("sender_is_msb")
    }

    /// [10] Wenn SG4 STS+7++xxx+xxx+E01/E03 (Transaktionsgrund befristete Anmeldung) vorhanden
    fn evaluate_10(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some(val) = sts.elements.get(4).and_then(|e| e.first()).map(|s| s.as_str()) {
                match val {
                    "E01" | "E03" => return ConditionResult::True,
                    _ => {}
                }
            }
        }
        if sts_segments.is_empty() {
            ConditionResult::Unknown
        } else {
            ConditionResult::False
        }
    }

    /// [11] Wenn SG4 STS+7++ZG9/ZH1/ZH2 (Transaktionsgrund: Aufhebung einer zukünftigen Zuordnung wegen Auszug des Kunden / -wegen Stilllegung / -wegen aufgehobenem Vertragsverhältnis) nicht vorhanden
    fn evaluate_11(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "7");
        for sts in &sts_segments {
            if let Some(val) = sts.elements.get(2).and_then(|e| e.first()).map(|s| s.as_str()) {
                match val {
                    "ZG9" | "ZH1" | "ZH2" => return ConditionResult::False,
                    _ => {}
                }
            }
        }
        ConditionResult::True
    }

    /// [12] Wenn SG4 DTM+471 (Ende zum nächstmöglichem Termin) nicht vorhanden
    fn evaluate_12(&self, ctx: &EvaluationContext) -> ConditionResult {
        if ctx.find_segments_with_qualifier("DTM", 0, "471").is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

    /// [13] Wenn SG4 STS+E01++Z01 (Status der Antwort: Zustimmung mit Terminänderung) nicht vorhanden
    fn evaluate_13(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts.elements.get(2).and_then(|e| e.first()).is_some_and(|v| v == "Z01") {
                return ConditionResult::False;
            }
        }
        ConditionResult::True
    }

    /// [16] Wenn SG4 STS+E01++Z12 (Status der Antwort: Ablehnung Vertragsbindung) vorhanden
    fn evaluate_16(&self, ctx: &EvaluationContext) -> ConditionResult {
        let sts_segments = ctx.find_segments_with_qualifier("STS", 0, "E01");
        for sts in &sts_segments {
            if sts.elements.get(2).and_then(|e| e.first()).is_some_and(|v| v == "Z12") {
                return ConditionResult::True;
            }
        }
        ConditionResult::False
    }

    /// [18] Wenn SG4 DTM+93 (Ende zum) nicht vorhanden
    fn evaluate_18(&self, ctx: &EvaluationContext) -> ConditionResult {
        let dtm_segments = ctx.find_segments_with_qualifier("DTM", 0, "93");
        if dtm_segments.is_empty() {
            ConditionResult::True
        } else {
            ConditionResult::False
        }
    }

}
