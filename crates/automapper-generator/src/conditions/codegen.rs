use crate::conditions::condition_types::{ConfidenceLevel, GeneratedCondition};

/// Generates a complete Rust source file containing a ConditionEvaluator impl
/// with match arms dispatching to per-condition evaluation functions.
///
/// Output format mirrors the C# `ConditionCodeGenerator.GenerateClass`.
pub fn generate_condition_evaluator_file(
    message_type: &str,
    format_version: &str,
    conditions: &[GeneratedCondition],
    source_file: &str,
    preserved_method_bodies: &std::collections::HashMap<u32, String>,
) -> String {
    let class_name = format!(
        "{}ConditionEvaluator{}",
        to_pascal_case(message_type),
        format_version
    );

    let mut code = String::new();

    // Header
    code.push_str("// <auto-generated>\n");
    code.push_str("// Generated by automapper-generator generate-conditions\n");
    code.push_str(&format!("// AHB: {}\n", source_file));
    code.push_str(&format!(
        "// Generated: {}\n",
        chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));
    code.push_str("// </auto-generated>\n\n");

    code.push_str("use crate::eval::{ConditionEvaluator, ConditionResult, EvaluationContext};\n\n");

    // Struct definition
    code.push_str(&format!(
        "/// Generated condition evaluator for {} {}.\n",
        message_type, format_version
    ));
    code.push_str(&format!("pub struct {} {{\n", class_name));
    code.push_str("    // External condition IDs that require runtime context.\n");
    code.push_str("    external_conditions: std::collections::HashSet<u32>,\n");
    code.push_str("}\n\n");

    // Collect external condition numbers
    let external_ids: Vec<u32> = conditions
        .iter()
        .filter(|c| c.is_external)
        .map(|c| c.condition_number)
        .collect();

    // Default impl
    code.push_str(&format!("impl Default for {} {{\n", class_name));
    code.push_str("    fn default() -> Self {\n");
    if external_ids.is_empty() {
        code.push_str("        let external_conditions = std::collections::HashSet::new();\n");
    } else {
        code.push_str("        let mut external_conditions = std::collections::HashSet::new();\n");
        for id in &external_ids {
            code.push_str(&format!("        external_conditions.insert({});\n", id));
        }
    }
    code.push_str("        Self { external_conditions }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // ConditionEvaluator impl
    code.push_str(&format!("impl ConditionEvaluator for {} {{\n", class_name));

    // Merge new conditions and preserved conditions, sorted by condition number
    let mut all_condition_numbers: Vec<u32> = conditions
        .iter()
        .map(|c| c.condition_number)
        .chain(preserved_method_bodies.keys().copied())
        .collect();
    all_condition_numbers.sort();
    all_condition_numbers.dedup();

    // message_type() and format_version() methods
    code.push_str(&format!(
        "    fn message_type(&self) -> &str {{\n        \"{}\"\n    }}\n\n",
        message_type
    ));
    code.push_str(&format!(
        "    fn format_version(&self) -> &str {{\n        \"{}\"\n    }}\n\n",
        format_version
    ));

    // evaluate() method with match arms
    let ctx_prefix = if all_condition_numbers.is_empty() {
        "_ctx"
    } else {
        "ctx"
    };
    code.push_str(&format!(
        "    fn evaluate(&self, condition: u32, {}: &EvaluationContext) -> ConditionResult {{\n",
        ctx_prefix
    ));
    code.push_str("        match condition {\n");

    for &num in &all_condition_numbers {
        code.push_str(&format!(
            "            {} => self.evaluate_{}(ctx),\n",
            num, num
        ));
    }
    code.push_str("            _ => ConditionResult::Unknown,\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    // is_external() method
    code.push_str("    fn is_external(&self, condition: u32) -> bool {\n");
    code.push_str("        self.external_conditions.contains(&condition)\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Private evaluation methods
    code.push_str(&format!("impl {} {{\n", class_name));

    for condition in conditions {
        generate_condition_method(&mut code, condition);
    }

    // Preserved methods (from previous generation, high-confidence, unchanged)
    // These are complete method blocks including doc comments.
    let mut preserved_nums: Vec<u32> = preserved_method_bodies.keys().copied().collect();
    preserved_nums.sort();
    for num in preserved_nums {
        // Only include if not already generated as a new condition
        if !conditions.iter().any(|c| c.condition_number == num) {
            if let Some(block) = preserved_method_bodies.get(&num) {
                code.push_str(block);
                if !block.ends_with('\n') {
                    code.push('\n');
                }
                code.push('\n');
            }
        }
    }

    code.push_str("}\n");

    code
}

/// Generates a single condition evaluation method.
fn generate_condition_method(code: &mut String, condition: &GeneratedCondition) {
    let num = condition.condition_number;

    // Doc comment
    code.push_str(&format!("    /// [{}]", num));
    if let Some(ref desc) = condition.original_description {
        code.push_str(&format!(" {}", escape_doc_comment(desc)));
    }
    code.push('\n');

    if condition.is_external {
        code.push_str("    /// EXTERNAL: Requires context from outside the message.\n");
    }

    if let Some(ref fields) = condition.referencing_fields {
        if !fields.is_empty() {
            code.push_str("    /// Referenced by:\n");
            for field in fields.iter().take(10) {
                code.push_str(&format!("    /// - {}\n", escape_doc_comment(field)));
            }
            if fields.len() > 10 {
                code.push_str(&format!("    /// - ... and {} more\n", fields.len() - 10));
            }
        }
    }

    // Confidence annotation comment
    if condition.confidence == ConfidenceLevel::Medium {
        if let Some(ref reasoning) = condition.reasoning {
            code.push_str(&format!(
                "    // REVIEW: {} (medium confidence)\n",
                reasoning
            ));
        }
    }

    // Method signature
    code.push_str(&format!(
        "    fn evaluate_{}(&self, ctx: &EvaluationContext) -> ConditionResult {{\n",
        num
    ));

    // Method body
    if condition.is_external {
        code.push_str(&format!(
            "        ctx.external.evaluate(\"{}\")\n",
            condition
                .external_name
                .as_deref()
                .unwrap_or(&format!("condition_{}", num))
        ));
    } else if condition.confidence == ConfidenceLevel::High
        || condition.confidence == ConfidenceLevel::Medium
    {
        if let Some(ref rust_code) = condition.rust_code {
            code.push_str(&indent_body(rust_code, 8));
        } else {
            code.push_str(&format!("        // TODO: Implement condition [{}]\n", num));
            code.push_str("        ConditionResult::Unknown\n");
        }
    } else {
        // Low confidence
        code.push_str(&format!(
            "        // TODO: Condition [{}] requires manual implementation\n",
            num
        ));
        if let Some(ref reasoning) = condition.reasoning {
            code.push_str(&format!("        // Reason: {}\n", reasoning));
        }
        code.push_str("        ConditionResult::Unknown\n");
    }

    code.push_str("    }\n\n");
}

/// Indents a multi-line code body to the specified column.
fn indent_body(body: &str, spaces: usize) -> String {
    let indent = " ".repeat(spaces);
    let lines: Vec<&str> = body.lines().collect();

    // Find minimum indentation
    let min_indent = lines
        .iter()
        .filter(|l| !l.trim().is_empty())
        .map(|l| l.len() - l.trim_start().len())
        .min()
        .unwrap_or(0);

    let mut result = String::new();
    for line in &lines {
        if line.trim().is_empty() {
            result.push('\n');
        } else {
            let stripped = if line.len() > min_indent {
                &line[min_indent..]
            } else {
                line.trim_start()
            };
            result.push_str(&indent);
            result.push_str(stripped);
            result.push('\n');
        }
    }
    result
}

fn escape_doc_comment(text: &str) -> String {
    text.replace('<', "&lt;").replace('>', "&gt;")
}

fn to_pascal_case(input: &str) -> String {
    if input.is_empty() {
        return input.to_string();
    }
    let mut chars = input.chars();
    let first = chars.next().unwrap().to_uppercase().to_string();
    first + &chars.as_str().to_lowercase()
}
