use crate::error::GeneratorError;
use crate::schema::mig::MigSchema;

/// Generates a `VersionConfig` trait impl block for the given format version.
///
/// This generates code like:
/// ```rust,ignore
/// impl VersionConfig for FV2510 {
///     const VERSION: FormatVersion = FormatVersion::FV2510;
///     type MarktlokationMapper = MarktlokationMapperV2510;
///     type VertragMapper = VertragMapperV2510;
///     // ...
/// }
/// ```
pub fn generate_version_config(mig: &MigSchema) -> Result<String, GeneratorError> {
    let fv = &mig.format_version;
    let fv_variant = fv.replace("FV", "V"); // FV2510 -> V2510
    let struct_name = fv.clone(); // FV2510

    let mut code = String::new();

    // Header
    code.push_str("// <auto-generated>\n");
    code.push_str("//     This code was generated by automapper-generator.\n");
    code.push_str(&format!(
        "//     Source: {} {} {}\n",
        mig.message_type,
        mig.variant.as_deref().unwrap_or(""),
        mig.version
    ));
    code.push_str("// </auto-generated>\n\n");

    code.push_str("use automapper_core::traits::{Mapper, VersionConfig};\n");
    code.push_str("use automapper_core::FormatVersion;\n\n");

    // Marker struct
    code.push_str(&format!(
        "/// Marker type for format version {}.\n",
        fv
    ));
    code.push_str(&format!("pub struct {};\n\n", struct_name));

    // VersionConfig impl
    code.push_str(&format!(
        "impl VersionConfig for {} {{\n",
        struct_name
    ));
    code.push_str(&format!(
        "    const VERSION: FormatVersion = FormatVersion::{};\n",
        fv
    ));

    // Generate associated types from detected entities in segment groups
    let entity_types = detect_mapper_types(mig);
    for (entity_name, _mapper_name) in &entity_types {
        code.push_str(&format!(
            "    type {}Mapper = {}Mapper{};\n",
            entity_name, entity_name, fv_variant
        ));
    }

    code.push_str("}\n");

    Ok(code)
}

/// Detects entity types that need mapper associated types.
fn detect_mapper_types(mig: &MigSchema) -> Vec<(String, String)> {
    let mut types = Vec::new();

    // Well-known UTILMD entity types
    let known_entities = [
        ("Marktlokation", "SG8"),
        ("Messlokation", "SG8"),
        ("Netzlokation", "SG8"),
        ("Zaehler", "SG10"),
        ("Geschaeftspartner", "SG2"),
        ("Vertrag", "SG12"),
        ("Prozessdaten", ""),
        ("Zeitscheibe", "SG4"),
        ("SteuerbareRessource", "SG8"),
        ("TechnischeRessource", "SG8"),
    ];

    for (entity, sg) in &known_entities {
        // Check if the group exists in the MIG (or top-level for empty sg)
        let exists = if sg.is_empty() {
            true
        } else {
            has_segment_group(mig, sg)
        };

        if exists {
            types.push((entity.to_string(), entity.to_string()));
        }
    }

    types
}

fn has_segment_group(mig: &MigSchema, group_id: &str) -> bool {
    fn search_groups(groups: &[crate::schema::mig::MigSegmentGroup], id: &str) -> bool {
        for group in groups {
            if group.id == id {
                return true;
            }
            if search_groups(&group.nested_groups, id) {
                return true;
            }
        }
        false
    }
    search_groups(&mig.segment_groups, group_id)
}
