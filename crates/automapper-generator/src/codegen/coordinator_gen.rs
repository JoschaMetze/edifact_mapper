use std::collections::HashSet;

use crate::codegen::segment_order::OrderedSegmentEntry;
use crate::error::GeneratorError;
use crate::schema::mig::MigSchema;

/// Generates coordinator registration code from MIG schema.
///
/// This produces a `UtilmdCoordinator` implementation with:
/// - Mapper registration in `new()`
/// - Segment dispatch in `on_segment()`
/// - Write ordering in `generate()`
pub fn generate_coordinator(
    mig: &MigSchema,
    ordered_segments: &[OrderedSegmentEntry],
) -> Result<String, GeneratorError> {
    let msg_type_pascal = to_pascal_case(&mig.message_type);
    let variant_str = mig.variant.as_deref().unwrap_or("");
    let class_name = format!(
        "{}{}Coordinator{}",
        msg_type_pascal, variant_str, mig.format_version
    );
    let fv_variant = mig.format_version.replace("FV", "V");

    let mut code = String::new();

    // Header
    code.push_str("// <auto-generated>\n");
    code.push_str("//     This code was generated by automapper-generator.\n");
    code.push_str(&format!(
        "//     Source: {} {} {}\n",
        mig.message_type, variant_str, mig.version
    ));
    code.push_str("// </auto-generated>\n\n");

    code.push_str("use automapper_core::coordinator::CoordinatorBase;\n");
    code.push_str("use automapper_core::traits::{Mapper, VersionConfig};\n");
    code.push_str("use automapper_core::FormatVersion;\n");
    code.push_str("use edifact_types::RawSegment;\n\n");

    // Coordinator struct
    code.push_str(&format!(
        "/// Coordinator for {} message processing.\n",
        mig.message_type
    ));
    code.push_str(&format!("pub struct {} {{\n", class_name));
    code.push_str("    mappers: Vec<Box<dyn Mapper>>,\n");
    code.push_str("}\n\n");

    // Constructor with mapper registration
    code.push_str(&format!("impl {} {{\n", class_name));
    code.push_str("    pub fn new() -> Self {\n");
    code.push_str("        let mappers: Vec<Box<dyn Mapper>> = Vec::new();\n\n");
    code.push_str("        // Register mappers in segment processing order\n");

    // Deduplicate segment IDs for registration
    let unique_segment_ids: Vec<&str> = {
        let mut seen = HashSet::new();
        ordered_segments
            .iter()
            .filter(|e| seen.insert(e.segment_id.as_str()))
            .map(|e| e.segment_id.as_str())
            .collect()
    };

    code.push_str("        // TODO: Register concrete mapper instances here\n");
    code.push_str("        // Example:\n");
    code.push_str(&format!(
        "        // mappers.push(Box::new(GeschaeftspartnerMapper{}::default()));\n",
        fv_variant
    ));
    code.push_str(&format!(
        "        // mappers.push(Box::new(ProzessdatenMapper{}::default()));\n",
        fv_variant
    ));
    code.push('\n');
    code.push_str("        Self { mappers }\n");
    code.push_str("    }\n\n");

    // Segment dispatch
    code.push_str("    /// Routes a segment to the appropriate mapper.\n");
    code.push_str("    pub fn dispatch_segment(&mut self, segment: &RawSegment) {\n");
    code.push_str("        match segment.id {\n");

    for seg_id in &unique_segment_ids {
        let group_comment = ordered_segments
            .iter()
            .find(|e| e.segment_id == *seg_id)
            .and_then(|e| e.group_id.as_deref())
            .map(|g| format!(" ({})", g))
            .unwrap_or_default();

        code.push_str(&format!(
            "            \"{}\" => {{}}{} // TODO: route to mapper\n",
            seg_id, group_comment
        ));
    }

    code.push_str("            _ => {} // Unknown segment\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    // Write ordering
    code.push_str("    /// Returns the MIG-defined segment write order.\n");
    code.push_str("    pub fn segment_write_order(&self) -> &'static [&'static str] {\n");
    code.push_str("        &[\n");

    for entry in ordered_segments {
        let optional = if entry.is_optional { " (optional)" } else { "" };
        let group = entry
            .group_id
            .as_deref()
            .map(|g| format!(" in {}", g))
            .unwrap_or_default();
        code.push_str(&format!(
            "            \"{}\", // {}{}{}\n",
            entry.segment_id, entry.counter, group, optional
        ));
    }

    code.push_str("        ]\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    Ok(code)
}

fn to_pascal_case(input: &str) -> String {
    if input.is_empty() {
        return input.to_string();
    }
    let mut chars = input.chars();
    let first = chars.next().unwrap().to_uppercase().to_string();
    first + &chars.as_str().to_lowercase()
}
