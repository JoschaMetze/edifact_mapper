---
source: crates/automapper-generator/src/codegen/pid_type_gen.rs
expression: source
---
impl Pid55001Sg10 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let cav = if peek_is(segments, cursor, "CAV") {
            Some(SegCav::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        let cci = if peek_is(segments, cursor, "CCI") {
            Some(SegCci::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if cav.is_none() && cci.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            cav,
            cci,
        })
    }
}

impl Pid55001Sg12Z04 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let nad = if peek_is(segments, cursor, "NAD") {
            Some(SegNad::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if nad.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            nad,
        })
    }
}

impl Pid55001Sg12Z09 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let nad = if peek_is(segments, cursor, "NAD") {
            Some(SegNad::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if nad.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            nad,
        })
    }
}

impl Pid55001Sg2 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let nad = if peek_is(segments, cursor, "NAD") {
            Some(SegNad::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if nad.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg3_ic = Vec::new();
        while let Some(item) = Pid55001Sg3Ic::from_segments(segments, cursor) {
            sg3_ic.push(item);
        }
        Some(Self {
            nad,
            sg3_ic,
        })
    }
}

impl Pid55001Sg3Ic {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let com = if peek_is(segments, cursor, "COM") {
            Some(SegCom::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        let cta = if peek_is(segments, cursor, "CTA") {
            Some(SegCta::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if com.is_none() && cta.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            com,
            cta,
        })
    }
}

impl Pid55001Sg4 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let dtm = if peek_is(segments, cursor, "DTM") {
            Some(SegDtm::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        let ide = if peek_is(segments, cursor, "IDE") {
            Some(SegIde::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        let sts = if peek_is(segments, cursor, "STS") {
            Some(SegSts::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if dtm.is_none() && ide.is_none() && sts.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg12_z09 = Vec::new();
        while let Some(item) = Pid55001Sg12Z09::from_segments(segments, cursor) {
            sg12_z09.push(item);
        }
        let mut sg12_z04 = Vec::new();
        while let Some(item) = Pid55001Sg12Z04::from_segments(segments, cursor) {
            sg12_z04.push(item);
        }
        let mut sg5_z16 = Vec::new();
        while let Some(item) = Pid55001Sg5Z16::from_segments(segments, cursor) {
            sg5_z16.push(item);
        }
        let mut sg5_z22 = Vec::new();
        while let Some(item) = Pid55001Sg5Z22::from_segments(segments, cursor) {
            sg5_z22.push(item);
        }
        let mut sg6 = Vec::new();
        while let Some(item) = Pid55001Sg6::from_segments(segments, cursor) {
            sg6.push(item);
        }
        let mut sg8_z79 = Vec::new();
        while let Some(item) = Pid55001Sg8Z79::from_segments(segments, cursor) {
            sg8_z79.push(item);
        }
        let mut sg8_zh0 = Vec::new();
        while let Some(item) = Pid55001Sg8Zh0::from_segments(segments, cursor) {
            sg8_zh0.push(item);
        }
        let mut sg8_z01 = Vec::new();
        while let Some(item) = Pid55001Sg8Z01::from_segments(segments, cursor) {
            sg8_z01.push(item);
        }
        let mut sg8_z75 = Vec::new();
        while let Some(item) = Pid55001Sg8Z75::from_segments(segments, cursor) {
            sg8_z75.push(item);
        }
        Some(Self {
            dtm,
            ide,
            sts,
            sg12_z09,
            sg12_z04,
            sg5_z16,
            sg5_z22,
            sg6,
            sg8_z79,
            sg8_zh0,
            sg8_z01,
            sg8_z75,
        })
    }
}

impl Pid55001Sg5Z16 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let loc = if peek_is(segments, cursor, "LOC") {
            Some(SegLoc::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if loc.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            loc,
        })
    }
}

impl Pid55001Sg5Z22 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let loc = if peek_is(segments, cursor, "LOC") {
            Some(SegLoc::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if loc.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            loc,
        })
    }
}

impl Pid55001Sg6 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let rff = if peek_is(segments, cursor, "RFF") {
            Some(SegRff::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if rff.is_none() {
            cursor.restore(saved);
            return None;
        }
        Some(Self {
            rff,
        })
    }
}

impl Pid55001Sg8Z01 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let seq = if peek_is(segments, cursor, "SEQ") {
            Some(SegSeq::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if seq.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg10 = Vec::new();
        while let Some(item) = Pid55001Sg10::from_segments(segments, cursor) {
            sg10.push(item);
        }
        Some(Self {
            seq,
            sg10,
        })
    }
}

impl Pid55001Sg8Z75 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let seq = if peek_is(segments, cursor, "SEQ") {
            Some(SegSeq::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if seq.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg10 = Vec::new();
        while let Some(item) = Pid55001Sg10::from_segments(segments, cursor) {
            sg10.push(item);
        }
        Some(Self {
            seq,
            sg10,
        })
    }
}

impl Pid55001Sg8Z79 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let pia = if peek_is(segments, cursor, "PIA") {
            Some(SegPia::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        let seq = if peek_is(segments, cursor, "SEQ") {
            Some(SegSeq::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if pia.is_none() && seq.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg10 = Vec::new();
        while let Some(item) = Pid55001Sg10::from_segments(segments, cursor) {
            sg10.push(item);
        }
        Some(Self {
            pia,
            seq,
            sg10,
        })
    }
}

impl Pid55001Sg8Zh0 {
    /// Try to assemble this group from segments at the cursor position.
    pub fn from_segments(
        segments: &[OwnedSegment],
        cursor: &mut SegmentCursor,
    ) -> Option<Self> {
        let saved = cursor.save();
        let seq = if peek_is(segments, cursor, "SEQ") {
            Some(SegSeq::from_owned(consume(segments, cursor)?))
        } else {
            None
        };
        if seq.is_none() {
            cursor.restore(saved);
            return None;
        }
        let mut sg10 = Vec::new();
        while let Some(item) = Pid55001Sg10::from_segments(segments, cursor) {
            sg10.push(item);
        }
        Some(Self {
            seq,
            sg10,
        })
    }
}

impl Pid55001 {
    /// Assemble this PID from a pre-tokenized segment list.
    pub fn from_segments(
        segments: &[OwnedSegment],
    ) -> Result<Self, AssemblyError> {
        let mut cursor = SegmentCursor::new(segments.len());

        let bgm = SegBgm::from_owned(expect_segment(segments, &mut cursor, "BGM")?);
        let dtm = SegDtm::from_owned(expect_segment(segments, &mut cursor, "DTM")?);
        let unh = SegUnh::from_owned(expect_segment(segments, &mut cursor, "UNH")?);
        let unt = SegUnt::from_owned(expect_segment(segments, &mut cursor, "UNT")?);
        let mut sg2 = Vec::new();
        while let Some(item) = Pid55001Sg2::from_segments(segments, &mut cursor) {
            sg2.push(item);
        }
        let mut sg4 = Vec::new();
        while let Some(item) = Pid55001Sg4::from_segments(segments, &mut cursor) {
            sg4.push(item);
        }

        Ok(Pid55001 {
            bgm,
            dtm,
            unh,
            unt,
            sg2,
            sg4,
        })
    }
}
