use crate::error::GeneratorError;
use crate::schema::ahb::AhbSchema;
use crate::schema::mig::MigSchema;

/// Entity types detected from MIG segment groups.
/// Each entity gets its own mapper stub file.
#[derive(Debug, Clone)]
pub struct DetectedEntity {
    /// The entity name in PascalCase (e.g., "Marktlokation", "Zaehler").
    pub name: String,
    /// The segment group ID where this entity is rooted (e.g., "SG8").
    pub segment_group: Option<String>,
    /// Key segments that belong to this entity.
    pub segments: Vec<String>,
    /// Qualifier values that identify this entity (e.g., SEQ+Z01).
    pub qualifiers: Vec<(String, String)>,
}

/// Generates mapper stub files â€” one file per entity type.
///
/// Returns a Vec of (filename, content) pairs.
pub fn generate_mapper_stubs(
    mig: &MigSchema,
    _ahb: &AhbSchema,
) -> Result<Vec<(String, String)>, GeneratorError> {
    let entities = detect_entities(mig);
    let mut output = Vec::new();

    for entity in &entities {
        let filename = format!(
            "{}_{}_mapper_{}.rs",
            mig.message_type.to_lowercase(),
            to_snake_case(&entity.name),
            mig.format_version.to_lowercase()
        );
        let content = generate_mapper_stub(mig, entity);
        output.push((filename, content));
    }

    // Also generate a mod.rs that re-exports all mappers
    let mod_content = generate_mod_file(mig, &entities);
    output.push((
        format!(
            "{}_mappers_{}_mod.rs",
            mig.message_type.to_lowercase(),
            mig.format_version.to_lowercase()
        ),
        mod_content,
    ));

    Ok(output)
}

/// Detect entity types from MIG structure.
///
/// For UTILMD, entities are identified by segment groups and SEQ qualifiers:
/// - SG2 -> Geschaeftspartner (parties)
/// - SG4 -> Zeitscheibe (time slices)
/// - SG8 with SEQ+Z01 -> Marktlokation master data
/// - SG8 with SEQ+Z98 -> Marktlokation informative data
/// - SG8 with SEQ+Z78 -> Lokationsbuendel
/// - SG10 -> Zaehler (meters, nested in SG8)
///
/// For a generic approach, we map known group patterns. Unknown groups
/// get a generic mapper stub named after the segment group.
fn detect_entities(mig: &MigSchema) -> Vec<DetectedEntity> {
    let mut entities = Vec::new();

    // Always add a Prozessdaten entity for top-level segments
    entities.push(DetectedEntity {
        name: "Prozessdaten".to_string(),
        segment_group: None,
        segments: mig.segments.iter().map(|s| s.id.clone()).collect(),
        qualifiers: Vec::new(),
    });

    for group in &mig.segment_groups {
        detect_entities_from_group(group, &mut entities);
    }

    entities
}

fn detect_entities_from_group(
    group: &crate::schema::mig::MigSegmentGroup,
    entities: &mut Vec<DetectedEntity>,
) {
    // Map well-known UTILMD groups to entity names
    let entity_name = match group.id.as_str() {
        "SG2" => "Geschaeftspartner".to_string(),
        "SG3" => "Referenz".to_string(),
        "SG4" => "Zeitscheibe".to_string(),
        "SG5" => "Antwortstatus".to_string(),
        "SG6" => "Dokument".to_string(),
        "SG8" => "Stammdaten".to_string(),
        "SG10" => "Zaehler".to_string(),
        "SG12" => "Vertrag".to_string(),
        _ => format!("SegmentGroup{}", group.id),
    };

    entities.push(DetectedEntity {
        name: entity_name,
        segment_group: Some(group.id.clone()),
        segments: group.segments.iter().map(|s| s.id.clone()).collect(),
        qualifiers: extract_qualifiers(group),
    });

    // Process nested groups
    for nested in &group.nested_groups {
        detect_entities_from_group(nested, entities);
    }
}

fn extract_qualifiers(group: &crate::schema::mig::MigSegmentGroup) -> Vec<(String, String)> {
    let mut qualifiers = Vec::new();

    for segment in &group.segments {
        // Check the first data element for qualifier codes
        if let Some(first_de) = segment.data_elements.first() {
            for code in &first_de.codes {
                qualifiers.push((segment.id.clone(), code.value.clone()));
            }
        }
    }

    qualifiers
}

fn generate_mapper_stub(mig: &MigSchema, entity: &DetectedEntity) -> String {
    let struct_name = format!(
        "{}Mapper{}",
        entity.name,
        mig.format_version.replace("FV", "V")
    );
    let builder_name = format!("{}Builder", entity.name);
    let snake_name = to_snake_case(&entity.name);

    let mut code = String::new();

    // Header
    code.push_str("// <auto-generated>\n");
    code.push_str("//     This code was generated by automapper-generator.\n");
    code.push_str(&format!(
        "//     Source: {} {} {}\n",
        mig.message_type,
        mig.variant.as_deref().unwrap_or(""),
        mig.version
    ));
    code.push_str("//\n");
    code.push_str("//     Changes to this file may be overwritten when regenerated.\n");
    code.push_str("// </auto-generated>\n\n");

    // Use statements
    code.push_str(
        "use automapper_core::traits::{SegmentHandler, Builder, EntityWriter, Mapper};\n",
    );
    code.push_str("use automapper_core::context::TransactionContext;\n");
    code.push_str("use automapper_core::writer::EdifactSegmentWriter;\n");
    code.push_str("use automapper_core::FormatVersion;\n");
    code.push_str("use edifact_types::RawSegment;\n\n");

    // Mapper struct
    code.push_str(&format!(
        "/// Mapper for {} in {}.\n",
        entity.name, mig.format_version
    ));
    if let Some(ref sg) = entity.segment_group {
        code.push_str(&format!("/// Segment group: {}\n", sg));
    }
    code.push_str(&format!("pub struct {} {{\n", struct_name));
    code.push_str(&format!("    builder: {},\n", builder_name));
    code.push_str("}\n\n");

    // Default impl
    code.push_str(&format!("impl Default for {} {{\n", struct_name));
    code.push_str("    fn default() -> Self {\n");
    code.push_str(&format!(
        "        Self {{ builder: {}::default() }}\n",
        builder_name
    ));
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // SegmentHandler impl
    code.push_str(&format!("impl SegmentHandler for {} {{\n", struct_name));
    code.push_str("    fn can_handle(&self, segment: &RawSegment) -> bool {\n");

    if entity.segments.is_empty() {
        code.push_str("        false\n");
    } else {
        code.push_str("        matches!(segment.id,\n");
        for (i, seg_id) in entity.segments.iter().enumerate() {
            let suffix = if i < entity.segments.len() - 1 {
                " |"
            } else {
                ""
            };
            code.push_str(&format!("            \"{}\"{}\n", seg_id, suffix));
        }
        code.push_str("        )\n");
    }

    code.push_str("    }\n\n");
    code.push_str(
        "    fn handle(&mut self, segment: &RawSegment, ctx: &mut TransactionContext) {\n",
    );
    code.push_str(&format!(
        "        // TODO: Implement {} segment handling\n",
        entity.name
    ));

    for seg_id in &entity.segments {
        code.push_str(&format!(
            "        // {}: parse and accumulate in builder\n",
            seg_id
        ));
    }

    code.push_str("    }\n");
    code.push_str("}\n\n");

    // EntityWriter impl
    code.push_str(&format!("impl EntityWriter for {} {{\n", struct_name));
    code.push_str(
        "    fn write(&self, writer: &mut EdifactSegmentWriter, ctx: &TransactionContext) {\n",
    );
    code.push_str(&format!(
        "        // TODO: Implement {} EDIFACT writing\n",
        entity.name
    ));
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Mapper impl
    code.push_str(&format!("impl Mapper for {} {{\n", struct_name));
    code.push_str("    fn format_version(&self) -> FormatVersion {\n");
    code.push_str(&format!("        FormatVersion::{}\n", mig.format_version));
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Builder struct (stub)
    code.push_str(&format!(
        "/// Builder for {} domain objects.\n",
        entity.name
    ));
    code.push_str("#[derive(Default)]\n");
    code.push_str(&format!("pub struct {} {{\n", builder_name));
    code.push_str(&format!(
        "    // TODO: Add fields for {} state accumulation\n",
        snake_name
    ));
    code.push_str("}\n\n");

    code.push_str(&format!("impl Builder<()> for {} {{\n", builder_name));
    code.push_str("    fn is_empty(&self) -> bool {\n");
    code.push_str("        true // TODO: Check accumulated state\n");
    code.push_str("    }\n\n");
    code.push_str("    fn build(&mut self) -> () {\n");
    code.push_str(&format!(
        "        // TODO: Build {} domain object\n",
        entity.name
    ));
    code.push_str("    }\n\n");
    code.push_str("    fn reset(&mut self) {\n");
    code.push_str("        *self = Self::default();\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

fn generate_mod_file(mig: &MigSchema, entities: &[DetectedEntity]) -> String {
    let mut code = String::new();

    code.push_str("// <auto-generated>\n");
    code.push_str(&format!(
        "//     Mapper modules for {} {}\n",
        mig.message_type, mig.format_version
    ));
    code.push_str("// </auto-generated>\n\n");

    for entity in entities {
        let mod_name = format!(
            "{}_{}_mapper_{}",
            mig.message_type.to_lowercase(),
            to_snake_case(&entity.name),
            mig.format_version.to_lowercase()
        );
        code.push_str(&format!("pub mod {};\n", mod_name));
    }

    code
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(ch.to_lowercase().next().unwrap_or(ch));
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("Marktlokation"), "marktlokation");
        assert_eq!(to_snake_case("Geschaeftspartner"), "geschaeftspartner");
        assert_eq!(to_snake_case("SegmentGroupSG8"), "segment_group_s_g8");
    }
}
